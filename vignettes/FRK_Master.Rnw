\documentclass{article}

% \VignetteEngine{knitr::knitr}
% \VignetteIndexEntry{FRK for prediction of CO2 from AIRS data}

\begin{document}
% \SweaveOpts{concordance=TRUE}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@

\begin{abstract}

Fixed Rank Kriging (FRK) is a spatial or spatio-temporal prediction method for large datasets. FRK hinges on the use of a spatial random effects (SRE) model, in which the spatially correlated random effect is decomposed using a set of basis functions. Dimensionality reduction ensures computationally efficient prediction, while the reconstructed random spatial field is, in general, non-stationary. Although FRK is relatively straightforward to implement, and despite its extensive use in remote sensing contexts, to date no software package has been developed to facilitate this task. The present article discusses the development or a new \emph{R} package, \texttt{FRK}, that facilitiates FRK on the most commonly used manifolds ($\mathbb{R}^1, \mathbb{R}^2$ and $\mathbb{S}^2$), both for spatial and spatio-temporal fields. In particular, it provides automatic basis function generation, automatic basic areal unit construction, functionality to incorporate multiple datasets with different supports, an expectation maximisation algorithm for parameter estimation, and functionality for point- or area-prediction. The package also has the capability for carrying out FRK on massive datasets on a distributed file system using a Hadoop backend. Use of the package is illustrated on several small examples and a massive dataset, implemented on the Amazon Elastic MapReduce web service.

\end{abstract}

\section{Introduction}

\section{Fixed Rank Kriging}

\subsection{SRE model}

\subsection{Estimation}

\subsection{Prediction}
\subsection{Applicaiton of sparse matrix inversion}

\section{Distributed computation with Hadoop}

\subsection{Hadoop and Rhipe for parallelising data and computations}

\subsection{FRK Operations to parallelise}

\section{Package layout}

\subsection{Classes and methods}

\subsection{Overall program structure}
\subsection{1D Simple example}

<<eval=TRUE>>=
library(sp)
library(ggplot2)
library(dplyr)
library(FRK)
#      devtools::load_all("~/Wollongong/pkgs/FRK",
#                              export_all = FALSE)
opts_FRK$set("progress",FALSE)
opts_FRK$set("parallel",0L)
@



<<eval=TRUE>>=
## Load data
set.seed(1)
sim_process <- data.frame(x = seq(0.005,0.995,by=0.01)) %>%
               mutate(y=0,proc = sin(x*10) + 0.3*rnorm(length(x)))

sim_data <- sample_n(sim_process,50) %>%
            mutate(z = proc + 0.1*rnorm(length(x)), std = 0.1)
coordinates(sim_data) = ~x + y# change into an sp object
@

<<eval=TRUE>>=
## Prediction (BAU) grid
grid_BAUs <- auto_BAUs(manifold=real_line(),data=sim_data,cellsize = c(0.01),type="grid")
grid_BAUs$fs = 1
@


<<eval=TRUE>>=
## Set up SRE model
G <- auto_basis(m = real_line(),data=sim_data,
                nres = 2,
                regular=6,
                type = "bisquare",
                subsamp = 20000)
@

<<eval=TRUE>>=
f <- z ~ 1
S <- SRE(f,list(sim_data),G,
         grid_BAUs,
         est_error = FALSE)
@

<<eval=TRUE>>=
S <- SRE.fit(S,n_EM = 50,tol = 1e-5,print_lik=TRUE)
@

<<eval=TRUE>>=
grid_BAUs <- SRE.predict(S,pred_locs = grid_BAUs,use_centroid = TRUE)
@

<<eval=TRUE>>=
X <- grid_BAUs@data %>%
     filter(x >= 0 & x <= 1)

g1 <- LinePlotTheme() +
           geom_line(data=X,aes(x,y=mu)) +
           geom_errorbar(data=X,aes(x=x,ymax = mu + 2*sqrt(var), ymin= mu - 2*sqrt(var))) +
           geom_point(data = data.frame(sim_data),aes(x=x,y=z),size=3) +
           geom_line(data=sim_process,aes(x=x,y=proc),col="red")

print(g1)
@


\subsection{2D Simple example}

% !Rnw root = FRK_Master.Rnw

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
# set global chunk options
# opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
# options(formatR.arrow=TRUE,width=90)
@


<<eval=TRUE>>=
library(sp)
library(ggplot2)
library(dplyr)
library(FRK)
#  devtools::load_all("~/Wollongong/pkgs/FRK",
                    # export_all = FALSE)

opts_FRK$set("progress",FALSE)
opts_FRK$set("parallel",0L)
set.seed(1)

## Get data
data(meuse)
meuse$fs <- 1
coordinates(meuse) = ~x+y # change into an sp object

# Generate observations with large spatial support
data(meuse.grid)
gridded(meuse.grid) = ~x + y

HexPts2 <- spsample(meuse.grid,
                    type = "hexagonal",
                    cellsize = 100)
HexPols2 <- HexPoints2SpatialPolygons(HexPts2)
HexPols_df2 <- SpatialPolygonsDataFrame(HexPols2,
                                        over(HexPols2,meuse) %>%
                                            select(zinc)) %>%
    subset(!is.na(zinc))

if(0) { ## Need INLA from here on

        # Generate BAUs
        HexPols_df <- auto_BAUs(manifold = plane(),cellsize = c(50,50),type = "grid",data = meuse,convex=-0.05)
        HexPols_df$fs <- 1

        ## Generate basis functions
        G <- auto_basis(m = plane(),data=meuse,nres = 2,
                        prune=10,type = "Gaussian")

        ## Setup SRE model
        f <- log(zinc) ~ 1
        S <- SRE(f,list(meuse,HexPols_df2),BAUs = HexPols_df, G,est_error=T)
        S <- SRE.fit(S,n_EM = 10,print_lik=TRUE)

        ## Point predict
        HexPols_df <- SRE.predict(S,use_centroid = TRUE)

        X <- SpatialPolygonsDataFrame_to_df(sp_polys = HexPols_df,
                                            vars = c("mu","var"))

        g1 <- EmptyTheme() +
            geom_polygon(data=X,aes(x,y,fill=mu,group=id),
                         colour="light grey") +
            scale_fill_distiller(palette="Spectral",trans="reverse") +
            geom_point(data=data.frame(meuse),
                       aes(x,y,fill=log(zinc)),
                       colour="black",
                       pch=21, size=3) +
            coord_fixed()

        g2 <- EmptyTheme() +
            geom_polygon(data=X,aes(x,y,fill=sqrt(var),group=id),
                         colour="light grey") +
            scale_fill_distiller(palette="Spectral",trans="reverse") +
            #geom_point(data=data.frame(meuse),
            #           aes(x,y),colour="black",pch=21, size=3) +
            coord_fixed()

        print(g1)
        print(g2)
}
@


\subsection{Modifying the distance measure - a 1D space-time example}

% NO INLA
% !Rnw root = FRK_Master.Rnw

%'     <<eval=TRUE>>=
%'     library(sp)
%'     library(ggplot2)
%'     library(dplyr)
%'     library(FRK)
%'     # devtools::load_all("~/Wollongong/pkgs/FRK",
%'     #                    export_all = FALSE)
%'     opts_FRK$set("progress",FALSE)
%'     opts_FRK$set("parallel",0L)
%'     @
%'
%'
%'
%'     <<eval=TRUE>>=
%'     ## Load data
%'     set.seed(1)
%'     N <- 50
%'     sim_process <- expand.grid(x = seq(0.005,0.995,by=0.01),
%'                                y = seq(0,10,by=0.1)) %>%
%'         mutate(proc = sin(x*10)*cos(y) + 0.3*rnorm(length(x)))
%'
%'     sim_data <- sample_n(sim_process,1000) %>%
%'         mutate(z = proc + 0.1*rnorm(length(x)), std = 0.1)
%'     coordinates(sim_data) = ~x + y# change into an sp object
%'     @
%'
%'     <<eval=TRUE>>=
%'     ## Prediction (BAU) grid
%'     grid_BAUs <- auto_BAUs(manifold=plane(),data=sim_data,cellsize = c(0.01,0.2),type="grid")
%'     grid_BAUs$fs = 1
%'     @
%'
%'
%'     <<eval=TRUE>>=
%'     ## Set up SRE model
%'     # G <- auto_basis(m = plane(),data=sim_data,
%'     #                 nres = 2,
%'     #                 regular = 2,
%'     #                 type = "bisquare",
%'     #                 subsamp = 20000)
%'
%'     ### OR ###
%'     scaler <- diag(c(1,0.1))
%'     asymm_measure <- new("measure",dist=function(x1,x2)  fields::rdist(x1 %*% scaler,x2 %*% scaler),dim=2L)
%'     OneD_ST <- plane()
%'     OneD_ST@metric <- asymm_measure
%'
%'     xgrid <- seq(0,1,length=5)
%'     ygrid <- seq(0,10,length=5)
%'     basis_locs <- xgrid %>%
%'         expand.grid(ygrid) %>%
%'         as.matrix()
%'     G <-  radial_basis(manifold = OneD_ST,
%'                        loc=basis_locs,
%'                        scale=rep(0.2,nrow(basis_locs)),
%'                        type="bisquare")
%'     S <- eval_basis(G,as.matrix(sim_process[c("x","y")]))
%'     sim_process$S <- S[,7]
%'     ggplot(sim_process) + geom_tile(aes(x,y,fill=S)) + coord_fixed()
%'     G@manifold@metric <- asymm_measure
%'     @
%'
%'     <<eval=TRUE>>=
%'     f <- z ~ 1
%'     S <- SRE(f,list(sim_data),G,
%'              grid_BAUs,
%'              est_error = FALSE)
%'     @
%'
%'     <<eval=TRUE>>=
%'     S <- SRE.fit(S,n_EM = 50,tol = 1e-5,print_lik=TRUE)
%'     @
%'
%'     <<eval=TRUE>>=
%'     grid_BAUs <- SRE.predict(S,pred_locs = grid_BAUs,use_centroid = TRUE)
%'     @
%'
%'     <<eval=TRUE>>=
%'     X <- SpatialPolygonsDataFrame_to_df(sp_polys = grid_BAUs,
%'                                         vars = c("mu","var")) %>%
%'         filter(x < 1.1 & x > -0.1 & y > -0.5 & y < 10.5)
%'
%'     g1 <- EmptyTheme() +
%'         geom_polygon(data=X,aes(x,y,fill=mu,group=id)) +
%'         scale_fill_distiller(palette="Spectral",trans="reverse") +
%'         geom_point(data=data.frame(sim_data),
%'                    aes(x,y,fill=z),
%'                    colour="black",
%'                    pch=21, size=3) +
%'         xlim(-0.1,1.1) + ylim(-0.4,10.4) +   coord_fixed()
%'     print(g1)
%'     @
%'



\section{Global prediction of global mid-tropospheric CO2 }

%'
%'     <<eval=TRUE>>=
%'     library(sp)
%'     library(ggplot2)
%'     library(dplyr)
%'     library(FRK)
%'     #       devtools::load_all("~/Wollongong/pkgs/FRK",
%'     #                               export_all = FALSE)
%'     opts_FRK$set("progress",FALSE)
%'     opts_FRK$set("parallel",0L)
%'     @
%'
%'
%'
%'     <<eval=TRUE>>=
%'     ## Load data
%'     data(AIRS_05_2003)
%'     AIRS_05_2003 <- filter(AIRS_05_2003,day %in% 1:1) %>%
%'         mutate(std=co2std) %>%
%'         select(lon,lat,co2avgret,std)
%'     coordinates(AIRS_05_2003) = ~lon+lat # change into an sp object
%'     proj4string(AIRS_05_2003)=CRS("+proj=longlat")
%'     @
%'
%'     <<eval=TRUE>>=
%'     ## Prediction (BAU) grid
%'     isea3h_sp_poldf <- auto_BAUs(manifold=sphere(),res=6,data=NULL,cellsize = c(5,5),type="grid")
%'     isea3h_sp_poldf$fs = 1
%'     @
%'
%'
%'     <<eval=TRUE>>=
%'     ## Set up SRE model
%'     G <- auto_basis(m = sphere(),data=AIRS_05_2003,
%'                     nres = 2,prune=15,
%'                     type = "bisquare",
%'                     subsamp = 20000)
%'     @
%'
%'     <<eval=TRUE>>=
%'     f <- co2avgret ~ lat + 1
%'     S <- SRE(f,list(AIRS_05_2003),G,
%'              isea3h_sp_poldf,
%'              est_error = FALSE)
%'     @
%'
%'     <<eval=TRUE>>=
%'     S <- SRE.fit(S,n_EM = 3,tol = 1e-5,print_lik=TRUE)
%'     @
%'
%'     <<eval=TRUE>>=
%'     isea3h_sp_poldf <- SRE.predict(S,pred_locs = isea3h_sp_poldf,use_centroid = TRUE)
%'     @
%'
%'     <<eval=TRUE>>=
%'     X <- SpatialPolygonsDataFrame_to_df(sp_polys = isea3h_sp_poldf,
%'                                         vars = c("mu","var"))
%'
%'     g1 <- (EmptyTheme() +
%'                geom_polygon(data=X,
%'                             aes(lon,lat,fill=mu,group=id))+
%'                scale_fill_distiller(palette="Spectral",trans="reverse") +
%'                coord_map("mollweide")) %>%
%'         draw_world(inc_border=FALSE)
%'
%'     mumin <- min(X$mu)
%'     mumax <- max(X$mu)
%'
%'     g2 <- (EmptyTheme() +
%'                geom_point(data=data.frame(AIRS_05_2003),
%'                           aes(lon,lat,
%'                               colour=pmin(pmax(
%'                                   co2avgret,mumin),
%'                                   mumax)),
%'                           size=2) +
%'                scale_colour_distiller(palette="Spectral",
%'                                       trans="reverse",
%'                                       guide_legend(title="co2")
%'                ) +
%'                coord_map("mollweide")) %>%
%'         draw_world(inc_border=TRUE)
%'
%'     print(g1)
%'     print(g2)
%'     @

\section{Global prediction of sea-surface temperatures using Hadoop}


\section{Conclusion}

\end{document}
